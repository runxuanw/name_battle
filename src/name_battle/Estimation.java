package name_battle;

import name_battle.attribute.AttributeBook;

public class Estimation {
	public String name;
	private String md5;
	private int power_level;
	
	public int estimate_name(String _name,AttributeBook attribute_list){
		name=_name;
		md5=getMD5(name.getBytes());		

		int strength=0;
		//generate attributes
		for(int counter=0;counter<attribute_list.attributes.size();counter++){
			String attribute_seed=md5.substring(counter*2, counter*2+2);
			int attribute_data=14+(Integer.decode("0x"+attribute_seed))%87;
			strength+=attribute_data;
			
		}
		
		power_level=strength/attribute_list.attributes.size();
		return power_level;
	}
	
	

	private static String getMD5(byte[] source)
	{
	String s = null;
	char hexDigits[] =
	{ // 用来将字节转换成 16 进制表示的字符
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b',
	'c', 'd', 'e', 'f'
	};
	try
	{
	java.security.MessageDigest md = java.security.MessageDigest.getInstance("MD5");
	md.update(source);
	// MD5 的计算结果是一个 128 位的长度整数，
	byte tmp[] = md.digest();
	// 用字节表示就是 16 个字节
	char str[] = new char[16 * 2]; // 每个字节用 16 进制表示的话，使用两个字符，
	// 所以表示成 16 进制需要 32 个字符
	int k = 0; // 表示转换结果中对应的字符位置
	for (int i = 0; i < 16; i++)
	{ // 从第一个字节开始，对 MD5 的每一个字节
	// 转换成 16 进制字符的转换
	byte byte0 = tmp[i]; // 取第 i 个字节
	str[k++] = hexDigits[byte0 >>> 4 & 0xf]; // 取字节中高 4 位的数字转换,
	// >>> 为逻辑右移（即无符号右移），将符号位一起右移

	// 取字节中低 4 位的数字转换
	str[k++] = hexDigits[byte0 & 0xf];
	}
	s = new String(str); // 换后的结果转换为字符串

	}
	catch (Exception e)
	{
	e.printStackTrace();
	}
	return s;
	
}
	
}
